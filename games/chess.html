<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>×©×—××˜ â€” ×œ×œ× ×¡×¤×¨×™×•×ª (AI + ×—× ×•×ª ×¡×§×™× ×™×)</title>
<style>
  :root{
    --square: 70px;
    --light: #eeeed2;
    --dark: #769656;
    --hint: rgba(255, 215, 0, 0.45);
    --sel: rgba(135, 206, 250, 0.55);
    --bg1:#1e1e2f; --bg2:#2d4d61;
    --pieceW:#111; --pieceB:#111;
  }
  body{
    margin:0; padding:24px;
    font-family: system-ui, -apple-system, "Segoe UI", Heebo, Arial, sans-serif;
    background: linear-gradient(135deg,var(--bg1),var(--bg2));
    color:#fff; display:flex; flex-direction:column; align-items:center; min-height:100vh;
  }
  h1{ margin:0 0 12px; font-size:clamp(20px,3vw,28px); }
  .toolbar{
    display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:center; margin-bottom:12px;
  }
  select,button{
    border:none; border-radius:12px; padding:10px 14px; font-weight:700; cursor:pointer; font-size:14px;
  }
  select{ color:#222; }
  button{ background:#6a5acd; color:#fff; }
  button:hover{ filter:brightness(1.05); transform:translateY(-1px); }
  .wrap{ display:flex; gap:18px; flex-wrap:wrap; align-items:flex-start; justify-content:center; }
  .board{
    display:grid; grid-template-columns: repeat(8, var(--square));
    grid-template-rows: repeat(8, var(--square));
    border-radius:14px; overflow:hidden; box-shadow:0 12px 30px rgba(0,0,0,.35);
  }
  .sq{
    width:var(--square); height:var(--square); display:flex; align-items:center; justify-content:center;
    user-select:none; position:relative; transition:background .12s ease;
  }
  .light{ background:var(--light); color:#111; }
  .dark{ background:var(--dark); color:#111; }
  .sq.sel::after{
    content:""; position:absolute; inset:0; background:var(--sel);
  }
  .sq.hint::before{
    content:""; position:absolute; width:18px; height:18px; border-radius:50%;
    background:var(--hint); box-shadow:0 0 0 2px rgba(0,0,0,.15) inset;
  }
  .sq.capture.hint::before{
    width: calc(var(--square) * 0.92); height: calc(var(--square) * 0.92); border-radius:10px;
    background: radial-gradient(transparent 40%, var(--hint) 41%);
  }

  /* ×ª×¦×•×’×ª ×›×œ×™× (×¡×§×™× ×™×) */
  .piece{ font-size:calc(var(--square) * 0.68); line-height:1; }
  .skin-unicode .piece{ color: var(--pieceColor, #111); text-shadow: 0 1px 0 rgba(255,255,255,.3); }
  .skin-letters .piece{
    width: calc(var(--square) * 0.76); height: calc(var(--square) * 0.76);
    border-radius: 50%; display:flex; align-items:center; justify-content:center;
    font-weight:900; font-family: ui-monospace, Menlo, Consolas, monospace;
    font-size: calc(var(--square) * 0.40);
    box-shadow: inset 0 -3px 8px rgba(0,0,0,.35), 0 2px 6px rgba(0,0,0,.25);
    color:#fff;
  }
  .skin-letters .piece.w{ background: linear-gradient(#6db3f2,#1e69de); }
  .skin-letters .piece.b{ background: linear-gradient(#ff9966,#ff5e62); }
  .skin-flat .piece{
    width: calc(var(--square) * 0.70); height: calc(var(--square) * 0.70);
    border-radius: 14px; display:flex; align-items:center; justify-content:center;
    font-weight:900; font-size: calc(var(--square) * 0.42);
    background: rgba(0,0,0,.06);
    color:#111;
    border: 2px solid rgba(0,0,0,.15);
    backdrop-filter: blur(2px);
  }
  .skin-flat .piece.w{ background: rgba(255,255,255,.65); }
  .skin-flat .piece.b{ background: rgba(0,0,0,.18); }

  .side{ min-width:280px; max-width:340px; display:flex; flex-direction:column; gap:10px; }
  .panel{ background:rgba(255,255,255,0.08); border-radius:14px; padding:12px 14px; backdrop-filter: blur(2px); }
  .status{ font-weight:800; font-size:16px; min-height:28px; }
  .moves{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space:pre-wrap; line-height:1.45; max-height:230px; overflow:auto; }

  .shop-btn{ background:#22c55e; }
  .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .coins{ margin-left:auto; background:rgba(255,255,255,.15); border-radius:999px; padding:6px 10px; font-weight:800; display:flex; gap:6px; align-items:center; }
  .coins i{ filter: drop-shadow(0 1px 2px rgba(0,0,0,.3)); }

  /* ××•×“××œ ×—× ×•×ª */
  .modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; backdrop-filter: blur(2px); }
  .modal.open{ display:flex; }
  .modal-bg{ position:absolute; inset:0; background: rgba(0,0,0,.45); }
  .modal-card{
    position:relative; z-index:2; width:min(920px, 95vw); max-height:85vh; overflow:auto;
    background:rgba(30,30,47,.95); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:16px;
    box-shadow: 0 20px 50px rgba(0,0,0,.5);
  }
  .shop-grid{ display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:12px; }
  .shop-item{
    background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:10px;
    display:flex; flex-direction:column; gap:8px;
  }
  .shop-item h4{ margin:0; font-size:14px; }
  .preview{
    height:120px; border-radius:12px; display:grid; grid-template-columns: repeat(4,1fr); grid-template-rows: repeat(2,1fr);
    overflow:hidden; border:1px solid rgba(255,255,255,.08);
  }
  .preview .cell{ display:flex; align-items:center; justify-content:center; font-size:28px; }
  .tag{ font-size:12px; opacity:.8; }
  .row-between{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
  .btn-small{ font-size:12px; padding:6px 10px; border-radius:10px; background:#6a5acd; border:none; color:#fff; font-weight:800; cursor:pointer; }
  .btn-small.green{ background:#22c55e; }
  .locked{ opacity:.6; position:relative; }
  .locked::after{ content:"ğŸ”’"; position:absolute; top:8px; right:8px; }
  a.home{
    margin-top:auto; color:#eee; text-decoration:none; font-weight:800; padding:10px 14px; border-radius:12px;
    border:1px solid rgba(255,255,255,.2);
  }
  a.home:hover{ color:#b8b8ff; border-color:#b8b8ff; }
  @media (max-width:540px){
    :root{ --square: 46px; }
    .side{ min-width:unset; width:100%; max-width:520px; }
  }
</style>
</head>
<body>

<h1>â™Ÿ ×©×—××˜ â€” AI + ×—× ×•×ª ×¡×§×™× ×™× (×œ×œ× ×¡×¤×¨×™×•×ª)</h1>

<div class="toolbar">
  <select id="mode">
    <option value="human">××“× × ×’×“ ××“×</option>
    <option value="ai" selected>×©×—×§ × ×’×“ ××—×©×‘</option>
  </select>
  <select id="aiSide">
    <option value="b" selected>×”××—×©×‘ ×©×—×•×¨</option>
    <option value="w">×”××—×©×‘ ×œ×‘×Ÿ</option>
  </select>
  <select id="aiLevel">
    <option value="0">AI: ×¨× ×“×•××œ×™</option>
    <option value="1" selected>AI: ×—××“×Ÿ (1 ply)</option>
    <option value="2">AI: ××™× ×™××§×¡ (2 ply)</option>
    <option value="3">AI: ××™× ×™××§×¡ (3 ply)</option>
  </select>
  <button id="new">××©×—×§ ×—×“×©</button>
  <button id="undo">×‘×˜×œ ××”×œ×š</button>
  <button id="shop" class="shop-btn">×—× ×•×ª ×¡×§×™× ×™×</button>
  <div class="coins" id="coinBox"><i>ğŸª™</i><span id="coins">300</span></div>
</div>

<div class="wrap">
  <div id="board" class="board" aria-label="×œ×•×— ×©×—××˜"></div>
  <div class="side">
    <div class="panel status" id="status">××•×›×Ÿ.</div>
    <div class="panel">
      <div style="font-weight:700; margin-bottom:6px;">×¨×©×•××ª ××”×œ×›×™×</div>
      <div id="moves" class="moves"></div>
    </div>
    <a class="home" href="home.html">â† ×—×–×¨×” ×œ××¡×š ×”×‘×™×ª</a>
  </div>
</div>

<!-- ×—× ×•×ª (××•×“××œ) -->
<div class="modal" id="shopModal" aria-hidden="true">
  <div class="modal-bg" id="shopClose"></div>
  <div class="modal-card">
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <h3 style="margin:0;">ğŸ›ï¸ ×—× ×•×ª ×¡×§×™× ×™×</h3>
      <button class="btn-small" id="shopX">×¡×’×•×¨</button>
    </div>

    <h4 style="margin:10px 0 6px;">ğŸ¨ ×¡×§×™× ×™× ×œ×œ×•×—</h4>
    <div id="boardSkins" class="shop-grid"></div>

    <h4 style="margin:16px 0 6px;">â™Ÿï¸ ×¡×§×™× ×™× ×œ×›×œ×™×</h4>
    <div id="pieceSkins" class="shop-grid"></div>
  </div>
</div>

<script>
/* ========= ×‘×¡×™×¡ ×©×—××˜ (×œ×œ× ×¡×¤×¨×™×•×ª) ========= */
const U = {
  w:{K:'â™”',Q:'â™•',R:'â™–',B:'â™—',N:'â™˜',P:'â™™'},
  b:{K:'â™š',Q:'â™›',R:'â™œ',B:'â™',N:'â™',P:'â™Ÿ'}
};
const PV = {K:10000, Q:900, R:500, B:330, N:320, P:100};

let board, turn, history;
const inBounds = (r,c)=> r>=0 && r<8 && c>=0 && c<8;
const colorOf = pc => pc ? pc[0] : null;
const typeOf = pc => pc ? pc[1] : null;

function startPosition(){
  return [
    ['bR','bN','bB','bQ','bK','bB','bN','bR'],
    ['bP','bP','bP','bP','bP','bP','bP','bP'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['wP','wP','wP','wP','wP','wP','wP','wP'],
    ['wR','wN','wB','wQ','wK','wB','wN','wR']
  ];
}
function findKing(bd, side){
  for(let r=0;r<8;r++) for(let c=0;c<8;c++)
    if(bd[r][c]===side+'K') return [r,c];
  return null;
}
function squareAttacked(bd, targetR, targetC, bySide){
  const dir = bySide==='w' ? -1 : 1;
  for(const [dr,dc] of [[dir,-1],[dir,1]]){
    const r=targetR+dr,c=targetC+dc;
    if(inBounds(r,c) && bd[r][c]===bySide+'P') return true;
  }
  for(const [dr,dc] of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]){
    const r=targetR+dr,c=targetC+dc;
    if(inBounds(r,c) && bd[r][c]===bySide+'N') return true;
  }
  for(const [dr,dc] of [[-1,-1],[-1,1],[1,-1],[1,1]]){
    let r=targetR+dr,c=targetC+dc;
    while(inBounds(r,c)){
      const pc=bd[r][c];
      if(pc){ if(colorOf(pc)===bySide && (typeOf(pc)==='B'||typeOf(pc)==='Q')) return true; break; }
      r+=dr; c+=dc;
    }
  }
  for(const [dr,dc] of [[-1,0],[1,0],[0,-1],[0,1]]){
    let r=targetR+dr,c=targetC+dc;
    while(inBounds(r,c)){
      const pc=bd[r][c];
      if(pc){ if(colorOf(pc)===bySide && (typeOf(pc)==='R'||typeOf(pc)==='Q')) return true; break; }
      r+=dr; c+=dc;
    }
  }
  for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
    if(!dr && !dc) continue;
    const r=targetR+dr,c=targetC+dc;
    if(inBounds(r,c) && bd[r][c]===bySide+'K') return true;
  }
  return false;
}
function pseudoMoves(bd, r, c){
  const pc = bd[r][c]; if(!pc) return [];
  const side=colorOf(pc), type=typeOf(pc), res=[];
  if(type==='P'){
    const dir = side==='w' ? -1 : 1;
    const startRow = side==='w' ? 6 : 1;
    if(inBounds(r+dir,c) && !bd[r+dir][c]){
      res.push([r+dir,c]);
      if(r===startRow && !bd[r+2*dir]?.[c]) res.push([r+2*dir,c]);
    }
    for(const dc of [-1,1]){
      const rr=r+dir, cc=c+dc;
      if(inBounds(rr,cc) && bd[rr][cc] && colorOf(bd[rr][cc])!==side) res.push([rr,cc]);
    }
  } else if(type==='N'){
    for(const [dr,dc] of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]){
      const rr=r+dr,cc=c+dc; if(!inBounds(rr,cc)) continue;
      const t=bd[rr][cc]; if(!t || colorOf(t)!==side) res.push([rr,cc]);
    }
  } else if(type==='B'||type==='R'||type==='Q'){
    const D=[]; if(type!=='R') D.push([-1,-1],[-1,1],[1,-1],[1,1]); if(type!=='B') D.push([-1,0],[1,0],[0,-1],[0,1]);
    for(const [dr,dc] of D){
      let rr=r+dr,cc=c+dc;
      while(inBounds(rr,cc)){
        const t=bd[rr][cc];
        if(!t) res.push([rr,cc]); else { if(colorOf(t)!==side) res.push([rr,cc]); break; }
        rr+=dr; cc+=dc;
      }
    }
  } else if(type==='K'){
    for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
      if(!dr && !dc) continue; const rr=r+dr,cc=c+dc; if(!inBounds(rr,cc)) continue;
      const t=bd[rr][cc]; if(!t || colorOf(t)!==side) res.push([rr,cc]);
    }
  }
  return res;
}
function cloneBoard(bd){ return bd.map(r=>r.slice()); }
function legalMovesFrom(bd, r, c){
  const side = colorOf(bd[r][c]); const out=[];
  for(const [rr,cc] of pseudoMoves(bd,r,c)){
    const copy=cloneBoard(bd); copy[rr][cc]=copy[r][c]; copy[r][c]='';
    if(typeOf(copy[rr][cc])==='P' && (rr===0||rr===7)) copy[rr][cc]=side+'Q';
    const kpos=findKing(copy, side); if(!kpos) continue;
    const inCheck=squareAttacked(copy,kpos[0],kpos[1], side==='w'?'b':'w');
    if(!inCheck) out.push([rr,cc]);
  }
  return out;
}
function allLegalMoves(bd, side){
  const all=[]; for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    if(colorOf(bd[r][c])!==side) continue;
    for(const m of legalMovesFrom(bd,r,c)) all.push([[r,c],m]);
  } return all;
}

/* ========= ×ª×¦×•×’×” ========= */
const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const movesEl = document.getElementById('moves');
const modeSel = document.getElementById('mode');
const aiSideSel = document.getElementById('aiSide');
const aiLevelSel = document.getElementById('aiLevel');
const btnNew = document.getElementById('new');
const btnUndo = document.getElementById('undo');

let selected=null, legalHints=[];
const fileChar = c => String.fromCharCode('a'.charCodeAt(0)+c);
const rankChar = r => String(8-r);
function notation(from,to,pc,captured){
  const t=typeOf(pc); const pieceLetter=(t==='P')?'':t; const cap=captured?'x':'-';
  return pieceLetter + fileChar(from[1]) + rankChar(from[0]) + cap + fileChar(to[1]) + rankChar(to[0]);
}

/* ========= ×¡×§×™× ×™× ========= */
let coins = 300;
const coinBox = document.getElementById('coins');

const BOARD_THEMES = [
  {id:'classic', name:'Classic', light:'#eeeed2', dark:'#769656', price:0, owned:true},
  {id:'charcoal', name:'Charcoal', light:'#cfd2d6', dark:'#4b5563', price:80, owned:false},
  {id:'sunset', name:'Sunset', light:'#ffe5d9', dark:'#ff9770', price:80, owned:false},
  {id:'ocean', name:'Ocean', light:'#d0f4ff', dark:'#2aa1c0', price:80, owned:false},
  {id:'vintage', name:'Vintage', light:'#f3ecd4', dark:'#c3a27b', price:80, owned:false},
];

const PIECE_THEMES = [
  {id:'unicode', name:'Unicode', type:'unicode', price:0, owned:true},
  {id:'letters', name:'Letters Discs', type:'letters', price:120, owned:false},
  {id:'flat', name:'Flat Blocks', type:'flat', price:120, owned:false},
];

let currentBoardTheme = 'classic';
let currentPieceTheme = 'unicode';

function applyBoardTheme(id){
  const t = BOARD_THEMES.find(x=>x.id===id)||BOARD_THEMES[0];
  document.documentElement.style.setProperty('--light', t.light);
  document.documentElement.style.setProperty('--dark', t.dark);
  currentBoardTheme = id;
}
function applyPieceTheme(id){
  const t = PIECE_THEMES.find(x=>x.id===id)||PIECE_THEMES[0];
  currentPieceTheme = id;
  draw(); // ××¨× ×“×¨ ××—×“×©
}

function pieceLabel(pc){
  const s=colorOf(pc), t=typeOf(pc);
  if(currentPieceTheme==='unicode'){
    return `<span class="piece ${currentPieceTheme}" style="--pieceColor:${s==='w'?'#111':'#111'}">${U[s][t]}</span>`;
  } else if(currentPieceTheme==='letters'){
    return `<span class="piece ${currentPieceTheme} ${s}">${t}</span>`;
  } else { // flat
    return `<span class="piece ${currentPieceTheme} ${s}">${t}</span>`;
  }
}

/* ========= ×¦×™×•×¨ ×œ×•×— ========= */
function draw(){
  boardEl.innerHTML='';
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const sq=document.createElement('div');
      sq.className='sq '+(((r+c)%2===0)?'light':'dark');
      sq.dataset.r=r; sq.dataset.c=c;
      const pc=board[r][c];
      if(pc){ sq.innerHTML = pieceLabel(pc); }
      if(selected && selected[0]===r && selected[1]===c) sq.classList.add('sel');
      for(const [rr,cc,cap] of legalHints){
        if(rr===r && cc===c){ sq.classList.add('hint'); if(cap) sq.classList.add('capture'); }
      }
      sq.addEventListener('click', onSquareWrapped);
      boardEl.appendChild(sq);
    }
  }
}

/* ========= ××¦×‘ ×•×¡×˜×˜×•×¡ ========= */
function updateStatus(){
  const side=(turn==='w')?'×œ×‘×Ÿ':'×©×—×•×¨';
  const moves=allLegalMoves(board, turn);
  const kpos=findKing(board, turn);
  const inCheck=kpos ? squareAttacked(board,kpos[0],kpos[1], turn==='w'?'b':'w'):false;
  if(moves.length===0){
    if(inCheck) statusEl.textContent=`××˜! ${side} ×ª×—×ª ×©×— â€” × ×™×¦×—×•×Ÿ ×œ-${turn==='w'?'×©×—×•×¨':'×œ×‘×Ÿ'}.`;
    else statusEl.textContent='×¤×˜! ×ª×™×§×•.';
    return;
  }
  statusEl.textContent=(inCheck?'×©×—! ':'')+`×ª×•×¨ ${side}`;
  movesEl.textContent = history.map((h,i)=>((i%2===0)?(Math.floor(i/2)+1)+'. ':'')+h).join(' ');
}

/* ========= ××™× ×˜×¨××§×¦×™×” ========= */
function onSquare(e){
  if(isAIsTurn()) return;
  const r=+e.currentTarget.dataset.r, c=+e.currentTarget.dataset.c;
  const pc=board[r][c];

  if(!selected){
    if(pc && colorOf(pc)===turn){
      selected=[r,c];
      legalHints=legalMovesFrom(board,r,c).map(([rr,cc])=>[rr,cc, !!board[rr][cc]]);
      draw();
    }
    return;
  }
  if(pc && colorOf(pc)===turn){
    selected=[r,c];
    legalHints=legalMovesFrom(board,r,c).map(([rr,cc])=>[rr,cc, !!board[rr][cc]]);
    draw(); return;
  }
  const isLegal=legalHints.some(([rr,cc])=>rr===r&&cc===c);
  if(!isLegal){ selected=null; legalHints=[]; draw(); return; }

  pushState();
  const from=selected.slice(); const moving=board[from[0]][from[1]]; const captured=board[r][c]||'';
  board[r][c]=moving; board[from[0]][from[1]]='';
  if(typeOf(board[r][c])==='P' && (r===0||r===7)) board[r][c]=colorOf(board[r][c])+'Q';
  history.push(notation(from,[r,c],moving,captured));
  selected=null; legalHints=[]; turn=(turn==='w')?'b':'w';
  draw(); updateStatus(); maybeAIMove();
}
const onSquareWrapped = (e)=>onSquare(e);

/* ========= Undo ========= */
const stack=[];
function pushState(){
  stack.push({ board: board.map(r=>r.slice()), turn, history: history.slice(), curBoard: currentBoardTheme, curPiece: currentPieceTheme, coins });
}
function popState(){
  const s=stack.pop(); if(!s) return;
  board=s.board.map(r=>r.slice()); turn=s.turn; history=s.history.slice();
  currentBoardTheme=s.curBoard; currentPieceTheme=s.curPiece; coins=s.coins; coinBox.textContent=coins;
  applyBoardTheme(currentBoardTheme); applyPieceTheme(currentPieceTheme);
  selected=null; legalHints=[]; draw(); updateStatus();
}

/* ========= AI ========= */
function isAIsTurn(){
  if(modeSel.value!=='ai') return false;
  return turn===aiSideSel.value;
}
function evaluate(bd){
  // ×—×•××¨ + × ×™×™×“×•×ª (×§×œ×”)
  let score=0;
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const pc=bd[r][c]; if(!pc) continue;
    score += (colorOf(pc)==='w'?1:-1) * (PV[typeOf(pc)]||0);
  }
  // × ×™×™×“×•×ª: ×”×‘×“×œ ×‘×›××•×ª ×”××¡×¢×™× ×”×—×•×§×™×™×
  const wm=allLegalMoves(bd,'w').length;
  const bm=allLegalMoves(bd,'b').length;
  score += 0.1*(wm-bm);
  return score;
}
function pickRandomMove(moves){ return moves[Math.floor(Math.random()*moves.length)]; }
function pickGreedyMove(){
  const side=turn, moves=allLegalMoves(board, side); if(moves.length===0) return null;
  let best=null, bestScore=(side==='w'?-Infinity:Infinity);
  for(const [[r,c],[rr,cc]] of moves){
    const copy=cloneBoard(board); const mv=copy[r][c]; const cap=copy[rr][cc];
    copy[rr][cc]=mv; copy[r][c]=''; if(typeOf(copy[rr][cc])==='P'&&(rr===0||rr===7)) copy[rr][cc]=side+'Q';
    const sc=evaluate(copy);
    if(side==='w'){ if(sc>bestScore){bestScore=sc; best=[[r,c],[rr,cc]];} }
    else{ if(sc<bestScore){bestScore=sc; best=[[r,c],[rr,cc]];} }
  }
  return best || moves[0];
}
function negamax(bd, depth, alpha, beta, side){
  // ×¡×™×•×
  if(depth===0) return (side==='w'?1:-1)*evaluate(bd);
  const moves=allLegalMoves(bd, side);
  if(moves.length===0){
    const kpos=findKing(bd, side);
    const inCheck=kpos && squareAttacked(bd,kpos[0],kpos[1], side==='w'?'b':'w');
    if(inCheck) return -99999 + (3-depth); // ××˜ ×›× ×’×“× ×•
    return 0; // ×¤×˜
  }
  let best=-Infinity;
  for(const [[r,c],[rr,cc]] of moves){
    const copy=cloneBoard(bd);
    const mv=copy[r][c];
    copy[rr][cc]=mv; copy[r][c]='';
    if(typeOf(copy[rr][cc])==='P'&&(rr===0||rr===7)) copy[rr][cc]=side+'Q';
    const val = -negamax(copy, depth-1, -beta, -alpha, side==='w'?'b':'w');
    if(val>best) best=val;
    if(val>alpha) alpha=val;
    if(alpha>=beta) break; // ×’×™×–×•×
  }
  return best;
}
function pickMinimaxMove(depth){
  const side=turn, moves=allLegalMoves(board, side); if(moves.length===0) return null;
  let bestMove=null, bestVal=-Infinity; let alpha=-Infinity, beta=Infinity;
  for(const [[r,c],[rr,cc]] of moves){
    const copy=cloneBoard(board);
    const mv=copy[r][c]; copy[rr][cc]=mv; copy[r][c]='';
    if(typeOf(copy[rr][cc])==='P'&&(rr===0||rr===7)) copy[rr][cc]=side+'Q';
    const val = -negamax(copy, depth-1, -beta, -alpha, side==='w'?'b':'w');
    if(val>bestVal){ bestVal=val; bestMove=[[r,c],[rr,cc]]; }
    if(val>alpha) alpha=val;
  }
  return bestMove || moves[0];
}
function maybeAIMove(){
  if(!isAIsTurn()) return;
  setTimeout(()=>{
    const lvl=+aiLevelSel.value;
    let mv=null;
    if(lvl===0) mv = pickRandomMove(allLegalMoves(board, turn));
    else if(lvl===1) mv = pickGreedyMove();
    else mv = pickMinimaxMove(lvl); // 2 ××• 3
    if(!mv) { updateStatus(); return; }

    pushState();
    const [[r,c],[rr,cc]] = mv;
    const moving=board[r][c]; const captured=board[rr][cc]||'';
    board[rr][cc]=moving; board[r][c]='';
    if(typeOf(board[rr][cc])==='P'&&(rr===0||rr===7)) board[rr][cc]=colorOf(board[rr][cc])+'Q';
    history.push(notation([r,c],[rr,cc],moving,captured));
    turn=(turn==='w')?'b':'w';
    draw(); updateStatus();
  }, 220);
}

/* ========= ××ª×—×•×œ ========= */
const btnShop = document.getElementById('shop');
const shopModal = document.getElementById('shopModal');
const shopClose = document.getElementById('shopClose');
const shopX = document.getElementById('shopX');
const boardSkinsEl = document.getElementById('boardSkins');
const pieceSkinsEl = document.getElementById('pieceSkins');

function reset(){
  board=startPosition(); turn='w'; history=[]; selected=null; legalHints=[];
  applyBoardTheme(currentBoardTheme); applyPieceTheme(currentPieceTheme);
  draw(); updateStatus(); maybeAIMove(); coinBox.textContent=coins;
}
btnNew.addEventListener('click', ()=>{ stack.length=0; reset(); });
btnUndo.addEventListener('click', ()=>{ popState(); });

/* ========= ×—× ×•×ª ========= */
function renderShop(){
  boardSkinsEl.innerHTML=''; pieceSkinsEl.innerHTML='';
  for(const t of BOARD_THEMES){
    const it=document.createElement('div'); it.className='shop-item'+(t.owned?'':' locked');
    it.innerHTML=`
      <div class="row-between"><h4>${t.name}</h4><span class="tag">#${t.id}</span></div>
      <div class="preview" style="grid-template-columns:repeat(4,1fr)">
        ${['', '', '', '', '', '', '', ''].map((_,i)=>{
          const light = t.light, dark=t.dark; const color=((i%2)===0)?light:dark;
          return `<div class="cell" style="background:${color}"></div>`;
        }).join('')}
      </div>
      <div class="row-between">
        <span class="tag">${t.owned?'×‘×‘×¢×œ×•×ª×š':'××—×™×¨: ğŸª™'+t.price}</span>
        <button class="btn-small ${t.owned?'green':''}" data-id="${t.id}" data-type="board">
          ${t.owned?(t.id===currentBoardTheme?'× ×‘×—×¨':'×‘×—×¨'): '×§× ×”'}
        </button>
      </div>
    `;
    boardSkinsEl.appendChild(it);
  }
  for(const t of PIECE_THEMES){
    const it=document.createElement('div'); it.className='shop-item'+(t.owned?'':' locked');
    it.innerHTML=`
      <div class="row-between"><h4>${t.name}</h4><span class="tag">#${t.id}</span></div>
      <div class="preview" style="place-items:center;">
        <!-- ×“××• ×§×˜×Ÿ -->
        <div style="display:flex; gap:6px; grid-column: span 4 / auto; grid-row: span 2 / auto; justify-content:center;">
          ${['wK','wQ','bK','bQ'].map(p=>{
            const s=colorOf(p), ch=typeOf(p);
            let html='';
            if(t.type==='unicode'){ html = `<span class="piece skin-unicode" style="font-size:28px">${U[s][ch]}</span>`; }
            else if(t.type==='letters'){ html = `<span class="piece skin-letters ${s}" style="width:40px;height:40px;font-size:16px">${ch}</span>`; }
            else { html = `<span class="piece skin-flat ${s}" style="width:40px;height:40px;font-size:18px">${ch}</span>`; }
            return html;
          }).join('')}
        </div>
      </div>
      <div class="row-between">
        <span class="tag">${t.owned?'×‘×‘×¢×œ×•×ª×š':'××—×™×¨: ğŸª™'+t.price}</span>
        <button class="btn-small ${t.owned?'green':''}" data-id="${t.id}" data-type="piece">
          ${t.owned?(t.id===currentPieceTheme?'× ×‘×—×¨':'×‘×—×¨'):'×§× ×”'}
        </button>
      </div>
    `;
    pieceSkinsEl.appendChild(it);
  }

  // ×××–×™× ×™×
  shopModal.querySelectorAll('button[data-id]').forEach(btn=>{
    btn.onclick = ()=>{
      const id=btn.getAttribute('data-id');
      const type=btn.getAttribute('data-type');
      if(type==='board'){
        const skin=BOARD_THEMES.find(x=>x.id===id);
        if(!skin.owned){
          if(coins<skin.price) { alert('××™×Ÿ ××¡×¤×™×§ ××˜×‘×¢×•×ª.'); return; }
          coins -= skin.price; skin.owned=true; coinBox.textContent=coins;
        }
        applyBoardTheme(id); draw(); renderShop();
      } else {
        const skin=PIECE_THEMES.find(x=>x.id===id);
        if(!skin.owned){
          if(coins<skin.price) { alert('××™×Ÿ ××¡×¤×™×§ ××˜×‘×¢×•×ª.'); return; }
          coins -= skin.price; skin.owned=true; coinBox.textContent=coins;
        }
        applyPieceTheme(id); draw(); renderShop();
      }
    };
  });
}
btnShop.addEventListener('click', ()=>{ shopModal.classList.add('open'); renderShop(); });
shopClose.addEventListener('click', ()=> shopModal.classList.remove('open'));
shopX.addEventListener('click', ()=> shopModal.classList.remove('open'));

/* ========= ×”×¤×¢×œ×” ========= */
reset();
</script>
</body>
</html>
