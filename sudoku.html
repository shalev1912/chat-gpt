<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>×¡×•×“×•×§×• ××ª×§×“×</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Heebo&display=swap');
  body {
    font-family: 'Heebo', sans-serif;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: #fff;
    margin: 0; padding: 0;
    display: flex; flex-direction: column; align-items: center;
    min-height: 100vh;
  }
  h1 {
    margin-top: 20px;
    margin-bottom: 5px;
  }
  #game {
    margin: 20px auto;
    background: rgba(0,0,0,0.25);
    border-radius: 15px;
    padding: 15px;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
  }
  table {
    border-collapse: collapse;
    margin: 10px auto;
  }
  td {
    width: 50px; height: 50px;
    text-align: center;
    vertical-align: middle;
    border: 1px solid #555;
    font-size: 24px;
    font-weight: 700;
    cursor: pointer;
    position: relative;
    background: rgba(255,255,255,0.05);
    user-select: none;
  }
  td.preset {
    color: #aaddff;
    font-weight: 900;
    cursor: default;
    background: rgba(0,0,0,0.3);
  }
  td.invalid {
    background: #ff4d4d;
    animation: blink 0.5s ease 2;
  }
  td.selected {
    background: rgba(255,255,255,0.2);
  }
  /* ×¢×™×¦×•×‘ ×‘×œ×•×§×™× 3x3 */
  td.block-right {
    border-right: 3px solid #888;
  }
  td.block-bottom {
    border-bottom: 3px solid #888;
  }
  /* pencil marks */
  .pencil-marks {
    font-size: 10px;
    color: rgba(255,255,255,0.6);
    position: absolute;
    top: 2px; left: 2px;
    width: 46px; height: 46px;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    pointer-events: none;
  }
  .pencil-marks span {
    text-align: center;
    line-height: 14px;
  }
  /* controls */
  #controls {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-top: 10px;
    flex-wrap: wrap;
  }
  button {
    padding: 10px 15px;
    font-size: 16px;
    border-radius: 8px;
    border: none;
    background: #4a4a8a;
    color: white;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0,0,0,0.4);
    transition: background 0.3s ease;
  }
  button:hover {
    background: #7a7add;
  }
  #message {
    margin-top: 10px;
    height: 24px;
    text-align: center;
    font-weight: 700;
    color: #ff5555;
    min-height: 24px;
  }
  #timer {
    margin-top: 10px;
    font-size: 16px;
    font-weight: 700;
    color: #ccc;
    user-select: none;
  }
  #difficulty {
    margin: 10px auto 0 auto;
    text-align: center;
  }
  #difficulty select {
    padding: 6px 10px;
    font-size: 16px;
    border-radius: 6px;
    border: none;
    background: #555;
    color: white;
    cursor: pointer;
  }
  #homeLink {
    margin-top: 20px;
    color: #aaddff;
    text-decoration: underline;
    cursor: pointer;
    font-size: 16px;
    user-select: none;
  }
  #homeLink:hover {
    color: #fff;
  }
  /* Animations */
  @keyframes blink {
    0%, 100% { background-color: #ff4d4d; }
    50% { background-color: rgba(255,77,77,0.6); }
  }
</style>
</head>
<body>
<h1>×¡×•×“×•×§×• ××ª×§×“×</h1>

<div id="difficulty">
  ×¨××ª ×§×•×©×™:
  <select id="difficultySelect">
    <option value="easy" selected>×§×œ</option>
    <option value="medium">×‘×™× ×•× ×™</option>
    <option value="hard">×§×©×”</option>
  </select>
  <button id="newGameBtn">×”×ª×—×œ ××©×—×§ ×—×“×©</button>
</div>

<div id="game" aria-label="×œ×•×— ×¡×•×“×•×§×•" role="application" tabindex="0">
  <!-- ×”×œ×•×— ×™×•×•×¦×¨ ×¤×” ×“×™× ××™×ª -->
</div>

<div id="controls" aria-label="×©×œ×™×˜×” ×‘××©×—×§">
  <button id="undoBtn" title="×‘×˜×œ ×¦×¢×“ ××—×¨×•×Ÿ">Undo â†©</button>
  <button id="redoBtn" title="×—×–×•×¨ ×¢×œ ×¦×¢×“ ×©×‘×•×˜×œ">Redo â†ª</button>
  <button id="clearPencilBtn" title="× ×§×” ×¡×™××•× ×™ ××¤×©×¨×•×™×•×ª">× ×§×” ×¡×™××•× ×™ ×¢×™×¤×¨×•×Ÿ</button>
  <button id="solveBtn" title="×¤×ª×•×¨ ××ª ×”×¤××–×œ ××•×˜×•××˜×™×ª">×¤×ª×•×¨ ××•×˜×•××˜×™×ª</button>
</div>

<div id="message" aria-live="polite" role="alert"></div>
<div id="timer" aria-label="×©×¢×•×Ÿ ×¢×¦×¨">×–××Ÿ: 00:00</div>

<div id="homeLink" tabindex="0" role="link" aria-label="×—×–×•×¨ ×œ××¡×š ×”×‘×™×ª">â† ×—×–×¨×” ×œ××¡×š ×”×‘×™×ª</div>

<script>
(() => {
  const SIZE = 9;
  const BLOCK = 3;

  const gameDiv = document.getElementById('game');
  const messageEl = document.getElementById('message');
  const timerEl = document.getElementById('timer');
  const difficultySelect = document.getElementById('difficultySelect');
  const newGameBtn = document.getElementById('newGameBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const clearPencilBtn = document.getElementById('clearPencilBtn');
  const solveBtn = document.getElementById('solveBtn');
  const homeLink = document.getElementById('homeLink');

  let board = [];
  let initialBoard = [];
  let pencilMarks = [];
  let selectedCell = null;
  let history = [];
  let redoStack = [];
  let timerInterval = null;
  let startTime = null;

  function createBoard() {
    gameDiv.innerHTML = '';
    const table = document.createElement('table');
    table.setAttribute('aria-label', '×œ×•×— ×¡×•×“×•×§×•');
    for(let r=0; r<SIZE; r++) {
      const tr = document.createElement('tr');
      for(let c=0; c<SIZE; c++) {
        const td = document.createElement('td');
        td.dataset.row = r;
        td.dataset.col = c;
        if ((c+1) % BLOCK === 0 && c !== SIZE - 1) td.classList.add('block-right');
        if ((r+1) % BLOCK === 0 && r !== SIZE - 1) td.classList.add('block-bottom');
        td.style.userSelect = "none";
        const pencilDiv = document.createElement('div');
        pencilDiv.className = 'pencil-marks';
        td.appendChild(pencilDiv);
        td.addEventListener('click', () => selectCell(r,c));
        tr.appendChild(td);
      }
      table.appendChild(tr);
    }
    gameDiv.appendChild(table);
  }

  function getCellElement(row,col){
    return gameDiv.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
  }

  function selectCell(row,col) {
    clearMessage();
    if(selectedCell){
      const [sr, sc] = selectedCell;
      getCellElement(sr, sc).classList.remove('selected');
    }
    selectedCell = [row,col];
    getCellElement(row,col).classList.add('selected');
  }

  function renderBoard() {
    for(let r=0; r<SIZE; r++){
      for(let c=0; c<SIZE; c++){
        const cell = getCellElement(r,c);
        cell.textContent = '';
        cell.classList.remove('preset', 'invalid');
        if(initialBoard[r][c] !== 0){
          cell.textContent = initialBoard[r][c];
          cell.classList.add('preset');
        } else {
          if(board[r][c] !== 0) {
            cell.textContent = board[r][c];
          }
        }
        const pencilDiv = cell.querySelector('.pencil-marks');
        pencilDiv.innerHTML = '';
        if(pencilMarks[r][c].size > 0 && board[r][c] === 0) {
          for(let n=1; n<=9; n++){
            const span = document.createElement('span');
            span.textContent = pencilMarks[r][c].has(n) ? n : '';
            pencilDiv.appendChild(span);
          }
        }
      }
    }
  }

  function isValidMove(row, col, num, currentBoard = board) {
    if(num < 1 || num > 9) return false;
    for(let c=0; c<SIZE; c++){
      if(c !== col && currentBoard[row][c] === num) return false;
    }
    for(let r=0; r<SIZE; r++){
      if(r !== row && currentBoard[r][col] === num) return false;
    }
    const br = Math.floor(row / BLOCK)*BLOCK;
    const bc = Math.floor(col / BLOCK)*BLOCK;
    for(let rr=br; rr<br+BLOCK; rr++){
      for(let cc=bc; cc<bc+BLOCK; cc++){
        if((rr !== row || cc !== col) && currentBoard[rr][cc] === num) return false;
      }
    }
    return true;
  }

  function isBoardComplete() {
    for(let r=0; r<SIZE; r++){
      for(let c=0; c<SIZE; c++){
        if(board[r][c] === 0 || !isValidMove(r,c,board[r][c])) return false;
      }
    }
    return true;
  }

  function showMessage(msg){
    messageEl.textContent = msg;
  }

  function clearMessage(){
    messageEl.textContent = '';
  }

  function saveHistory(){
    // ×©××•×¨ ×”×¢×ª×§ ×©×œ ×”×œ×•×— ×•×”×¤× ×¦'×œ×™× ×œ×”×™×¡×˜×•×¨×™×” (×œ-Undo)
    const snapshot = {
      board: board.map(r => r.slice()),
      pencilMarks: pencilMarks.map(r => r.map(s => new Set(s))),
      selectedCell: selectedCell ? [...selectedCell] : null,
    };
    history.push(snapshot);
    // × ×§×™ ××ª ×¢×¨××ª ×”-Redo
    redoStack = [];
    updateUndoRedoButtons();
  }

  function undo(){
    if(history.length === 0) return;
    const currentSnapshot = {
      board: board.map(r => r.slice()),
      pencilMarks: pencilMarks.map(r => r.map(s => new Set(s))),
      selectedCell: selectedCell ? [...selectedCell] : null,
    };
    redoStack.push(currentSnapshot);

    const prev = history.pop();
    board = prev.board.map(r => r.slice());
    pencilMarks = prev.pencilMarks.map(r => r.map(s => new Set(s)));
    selectedCell = prev.selectedCell;
    renderBoard();
    updateSelection();
    updateUndoRedoButtons();
    clearMessage();
  }

  function redo(){
    if(redoStack.length === 0) return;
    const currentSnapshot = {
      board: board.map(r => r.slice()),
      pencilMarks: pencilMarks.map(r => r.map(s => new Set(s))),
      selectedCell: selectedCell ? [...selectedCell] : null,
    };
    history.push(currentSnapshot);

    const next = redoStack.pop();
    board = next.board.map(r => r.slice());
    pencilMarks = next.pencilMarks.map(r => r.map(s => new Set(s)));
    selectedCell = next.selectedCell;
    renderBoard();
    updateSelection();
    updateUndoRedoButtons();
    clearMessage();
  }

  function updateUndoRedoButtons(){
    undoBtn.disabled = history.length === 0;
    redoBtn.disabled = redoStack.length === 0;
  }

  function updateSelection(){
    // ×”×¡×¨ ×‘×—×™×¨×” ×™×©× ×” ×•×”×•×¡×£ ×—×“×©×”
    document.querySelectorAll('td.selected').forEach(td => td.classList.remove('selected'));
    if(selectedCell){
      const [r,c] = selectedCell;
      getCellElement(r,c).classList.add('selected');
    }
  }

  function clearPencilMarks(){
    if(!selectedCell) {
      showMessage('×‘×—×¨ ×ª× ×›×“×™ ×œ× ×§×•×ª ×¡×™××•× ×™ ×¢×™×¤×¨×•×Ÿ');
      return;
    }
    const [r,c] = selectedCell;
    if(initialBoard[r][c] !== 0) {
      showMessage('×œ× × ×™×ª×Ÿ ×œ×©× ×•×ª ×¡×™××•× ×™ ×¢×™×¤×¨×•×Ÿ ×‘×ª× ×¨××©×•× ×™');
      return;
    }
    if(pencilMarks[r][c].size === 0){
      showMessage('××™×Ÿ ×¡×™××•× ×™ ×¢×™×¤×¨×•×Ÿ ×œ× ×§×•×ª ×‘×ª× ×–×”');
      return;
    }
    pencilMarks[r][c].clear();
    saveHistory();
    renderBoard();
    clearMessage();
  }

  // ×”×›× ×¡×ª ××¡×¤×¨ ×‘×ª× ×”× ×‘×—×¨ - num ×‘×™×Ÿ 1 ×œ-9 ××• 0 ×œ××—×™×§×”
  function inputNumber(num, pencil=false) {
    if(!selectedCell){
      showMessage('×‘×—×¨ ×ª× ×œ×¤× ×™ ×”×›× ×¡×ª ××¡×¤×¨');
      return;
    }
    const [r,c] = selectedCell;
    if(initialBoard[r][c] !== 0){
      showMessage('×œ× × ×™×ª×Ÿ ×œ×©× ×•×ª ××ª ×”××¡×¤×¨ ×”×¨××©×•× ×™');
      return;
    }
    if(pencil){
      if(num === 0) {
        showMessage('×‘×—×¨ ××¡×¤×¨ ×—×•×§×™ ×œ×¡×™××•×Ÿ ×¢×™×¤×¨×•×Ÿ');
        return;
      }
      if(pencilMarks[r][c].has(num)){
        pencilMarks[r][c].delete(num);
      } else {
        pencilMarks[r][c].add(num);
      }
      saveHistory();
      renderBoard();
      clearMessage();
      return;
    }
    // ×”×›× ×¡×ª ××¡×¤×¨ ×¨×’×™×œ×”
    if(num === 0) {
      board[r][c] = 0;
      pencilMarks[r][c].clear();
      saveHistory();
      renderBoard();
      clearMessage();
      return;
    }
    if(!isValidMove(r,c,num)){
      // ×¡×™××•×Ÿ ×©×’×™××” ×œ×–××Ÿ ×§×¦×¨
      const cell = getCellElement(r,c);
      cell.classList.add('invalid');
      setTimeout(() => cell.classList.remove('invalid'), 600);
      showMessage('×”×–× ×ª ××¡×¤×¨ ×œ× ×—×•×§×™×ª');
      return;
    }
    board[r][c] = num;
    pencilMarks[r][c].clear();
    saveHistory();
    renderBoard();
    clearMessage();
    if(isBoardComplete()){
      clearInterval(timerInterval);
      showMessage('×›×œ ×”×›×‘×•×“! ×”×©×œ××ª ××ª ×”×œ×•×— ğŸ‰');
    }
  }

  // ××¤×ª×— ×œ×¤×™×¦×•×œ ×œ×•×— - ×œ×™×™×¦×¨ ×œ×•×— ×¤×ª×¨×•×Ÿ ××• ×”×ª×—×œ×”
  function copyBoard(b){
    return b.map(r => r.slice());
  }

  // ××œ×’×•×¨×™×ª× ×¤×ª×¨×•×Ÿ (Backtracking)
  function solveSudoku(b=board) {
    for(let r=0; r<SIZE; r++){
      for(let c=0; c<SIZE; c++){
        if(b[r][c] === 0){
          for(let n=1; n<=9; n++){
            if(isValidMove(r,c,n,b)){
              b[r][c] = n;
              if(solveSudoku(b)) return true;
              b[r][c] = 0;
            }
          }
          return false;
        }
      }
    }
    return true;
  }

  // ×™×¦×™×¨×ª ××©×—×§ ×—×“×© - ×˜×•×¢×Ÿ ×¤××–×œ ××•×›×Ÿ ××¨××©
  // ×›××Ÿ ×”×©×ª××©×ª×™ ×‘×¤××–×œ×™× ×“×•×’××” ×œ×¤×™ ×¨××ª ×§×•×©×™
  const puzzles = {
    easy: [
      [0,0,2, 6,0,0, 7,0,1],
      [6,8,0, 0,7,0, 0,9,0],
      [1,9,0, 0,0,4, 5,0,0],
      [8,2,0, 1,0,0, 0,4,0],
      [0,0,4, 6,0,2, 9,0,0],
      [0,5,0, 0,0,3, 0,2,8],
      [0,0,9, 3,0,0, 0,7,4],
      [0,4,0, 0,5,0, 0,3,6],
      [7,0,3, 0,0,1, 8,0,0]
    ],
    medium: [
      [0,2,0, 6,0,8, 0,0,0],
      [5,8,0, 0,0,9, 7,0,0],
      [0,0,0, 0,4,0, 0,0,0],
      [3,7,0, 0,0,0, 5,0,0],
      [6,0,0, 0,0,0, 0,0,4],
      [0,0,8, 0,0,0, 0,1,3],
      [0,0,0, 0,2,0