<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>משחק סודוקו מודרני</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Heebo:wght@400;500;700&display=swap');

  :root {
    --main-bg: #1e1e2f;
    --cell-bg: #2a2a42;
    --cell-bg-fixed: #444466;
    --cell-bg-highlight: #37415a;
    --accent: #ffd166;
    --text-light: #eee;
    --text-dark: #333;
    --error-color: #ff6b6b;
  }

  * {
    box-sizing: border-box;
  }
  body {
    margin: 0; padding: 0;
    background: linear-gradient(135deg, #ff9a9e, #fad0c4, #a18cd1, #fbc1cc);
    background-size: 600% 600%;
    animation: bgShift 30s ease infinite;
    font-family: 'Heebo', sans-serif;
    color: var(--text-light);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 12px 8px 24px;
  }
  @keyframes bgShift {
    0% { background-position:0% 50%;}
    50% { background-position:100% 50%;}
    100% { background-position:0% 50%;}
  }

  h1 {
    margin: 8px 0 16px;
    font-weight: 700;
    font-size: 2rem;
    text-align: center;
    user-select: none;
  }

  #game-container {
    background: var(--main-bg);
    border-radius: 16px;
    padding: 16px 24px 32px;
    box-shadow: 0 12px 28px rgba(0,0,0,0.45);
    max-width: 400px;
    width: 100%;
  }

  /* Sudoku Grid */
  #sudoku-grid {
    display: grid;
    grid-template-columns: repeat(9, 1fr);
    grid-template-rows: repeat(9, 1fr);
    gap: 2px;
    background: var(--accent);
    border-radius: 12px;
    user-select: none;
  }
  .cell {
    background: var(--cell-bg);
    color: var(--text-light);
    font-size: 1.25rem;
    font-weight: 600;
    text-align: center;
    line-height: 1.5;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.25s;
    outline: none;
  }
  .cell.fixed {
    background: var(--cell-bg-fixed);
    cursor: default;
  }
  .cell.highlight {
    background: var(--cell-bg-highlight);
  }
  .cell.error {
    background: var(--error-color);
    color: white;
  }
  .cell:focus {
    box-shadow: 0 0 8px 2px var(--accent);
    background: var(--accent);
    color: var(--main-bg);
  }

  /* Bold borders for blocks */
  .cell.border-right {
    border-right: 3px solid var(--accent);
  }
  .cell.border-bottom {
    border-bottom: 3px solid var(--accent);
  }

  /* Controls */
  #controls {
    margin-top: 18px;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 12px;
  }
  select, button {
    padding: 8px 14px;
    font-size: 1rem;
    font-weight: 600;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    transition: background-color 0.25s;
    user-select: none;
  }
  select {
    flex-grow: 1;
    max-width: 140px;
  }
  button {
    background: var(--accent);
    color: var(--main-bg);
    flex-grow: 1;
    max-width: 110px;
  }
  button:hover {
    background: #e6b842;
  }
  button:active {
    background: #cfa62e;
  }

  /* Timer and Score */
  #info {
    margin-top: 20px;
    display: flex;
    justify-content: space-between;
    font-weight: 700;
    font-size: 1.1rem;
    user-select: none;
  }
  #score {
    color: var(--accent);
  }
  #timerToggle {
    background: transparent;
    border: 2px solid var(--accent);
    color: var(--accent);
    max-width: 140px;
  }
  #timerToggle.active {
    background: var(--accent);
    color: var(--main-bg);
  }

  /* Responsive */
  @media (max-width: 460px) {
    #game-container {
      max-width: 95vw;
      padding: 12px 16px 24px;
    }
    #controls {
      flex-direction: column;
      align-items: center;
    }
    select, button, #timerToggle {
      max-width: 100%;
      flex-grow: unset;
      width: 100%;
    }
  }
</style>
</head>
<body>
  <h1>משחק סודוקו מודרני</h1>

  <div id="game-container" role="main" aria-label="משחק סודוקו">
    <div id="sudoku-grid" aria-label="לוח סודוקו" tabindex="0"></div>

    <div id="controls" aria-label="בקרות המשחק">
      <select id="difficulty" aria-label="בחר רמת קושי">
        <option value="easy" selected>קל</option>
        <option value="medium">בינוני</option>
        <option value="hard">קשה</option>
      </select>
      <button id="newGameBtn" aria-label="התחל משחק חדש">התחל משחק</button>
      <button id="timerToggle" aria-pressed="false" aria-label="הפעל/כבה טיימר">הפעל טיימר</button>
    </div>

    <div id="info" aria-live="polite">
      <div>זמן: <span id="timer">00:00</span></div>
      <div>נקודות: <span id="score">0</span></div>
    </div>
  </div>

<script>
(() => {
  // Sudoku generator and solver adapted for 9x9
  // Using backtracking algorithm to generate a valid full board, then remove numbers by difficulty

  // Utilities
  function shuffle(array) {
    for(let i = array.length -1; i > 0; i--){
      let j = Math.floor(Math.random() * (i+1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }

  // Create a 9x9 empty grid
  function createEmptyGrid(){
    return Array(9).fill(0).map(() => Array(9).fill(0));
  }

  // Check if placing num at (row,col) is valid in grid
  function isValid(grid, row, col, num){
    // check row and column
    for(let i=0;i<9;i++){
      if(grid[row][i] === num) return false;
      if(grid[i][col] === num) return false;
    }
    // check 3x3 box
    let boxRow = Math.floor(row / 3) * 3;
    let boxCol = Math.floor(col / 3) * 3;
    for(let r=boxRow; r < boxRow+3; r++){
      for(let c=boxCol; c < boxCol+3; c++){
        if(grid[r][c] === num) return false;
      }
    }
    return true;
  }

  // Solve sudoku with backtracking
  function solveSudoku(grid){
    for(let r=0; r<9; r++){
      for(let c=0; c<9; c++){
        if(grid[r][c] === 0){
          for(let n=1; n<=9; n++){
            if(isValid(grid, r, c, n)){
              grid[r][c] = n;
              if(solveSudoku(grid)) return true;
              grid[r][c] = 0;
            }
          }
          return false;
        }
      }
    }
    return true;
  }

  // Generate a full solved board
  function generateFullBoard(){
    let grid = createEmptyGrid();
    // Fill diagonal boxes first for speed
    function fillBox(row,col){
      let nums = [1,2,3,4,5,6,7,8,9];
      shuffle(nums);
      let idx=0;
      for(let r=row;r<row+3;r++){
        for(let c=col;c<col+3;c++){
          grid[r][c] = nums[idx++];
        }
      }
    }
    for(let i=0; i<9; i+=3){
      fillBox(i,i);
    }
    solveSudoku(grid);
    return grid;
  }

  // Remove numbers according to difficulty
  // easy: ~35 givens, medium: ~27, hard: ~22
  function makePuzzle(fullGrid, difficulty){
    let attempts;
    switch(difficulty){
      case 'easy': attempts = 40; break;
      case 'medium': attempts = 50; break;
      case 'hard': attempts = 60; break;
      default: attempts = 40;
    }

    let puzzle = fullGrid.map(row => row.slice());

    while(attempts > 0){
      let r = Math.floor(Math.random() * 9);
      let c = Math.floor(Math.random() * 9);
      if(puzzle[r][c] !== 0){
        let backup = puzzle[r][c];
        puzzle[r][c] = 0;

        // Check uniqueness by attempting to solve with one solution (basic check)
        // To keep it simple, we don't do full uniqueness check here to keep speed

        attempts--;
      }
    }
    return puzzle;
  }

  // DOM references
  const gridElem = document.getElementById('sudoku-grid');
  const difficultySelect = document.getElementById('difficulty');
  const newGameBtn = document.getElementById('newGameBtn');
  const timerToggleBtn = document.getElementById('timerToggle');
  const timerDisplay = document.getElementById('timer');
  const scoreDisplay = document.getElementById('score');

  // Game state
  let fullBoard = null;
  let puzzleBoard = null;
  let selectedCell = null;
  let timerRunning = false;
  let timerInterval = null;
  let timeSeconds = 0;
  let score = 0;

  // Initialize game
  function initGame(){
    // Clear previous timer
    stopTimer();
    timeSeconds = 0;
    timerDisplay.textContent = '00:00';
    score = 0;
    scoreDisplay.textContent = score;

    // Generate full board and puzzle
    fullBoard = generateFullBoard();
    puzzleBoard = makePuzzle(fullBoard, difficultySelect.value);

    renderGrid(puzzleBoard);
  }

  // Render grid
  function renderGrid(board){
    gridElem.innerHTML = '';
    for(let r=0; r<9; r++){
      for(let c=0; c<9; c++){
        const cell = document.createElement('div');
        cell.classList.add('cell');
        if((c+1) % 3 === 0 && c !== 8) cell.classList.add('border-right');
        if((r+1) % 3 === 0 && r !== 8) cell.classList.add('border-bottom');

        if(board[r][c] !== 0){
          cell.textContent = board[r][c];
          cell.classList.add('fixed');
        } else {
          cell.textContent = '';
          cell.setAttribute('tabindex', '0');
          cell.addEventListener('click', () => {
            selectCell(cell, r, c);
          });
          cell.addEventListener('keydown', e => {
            if(e.key >= '1' && e.key <= '9'){
              setCellValue(cell, r, c, parseInt(e.key));
              e.preventDefault();
            }
            if(e.key === 'Backspace' || e.key === 'Delete' || e.key === '0'){
              setCellValue(cell, r, c, 0);
              e.preventDefault();
            }
            if(e.key === 'ArrowUp') moveSelection(r-1,c);
            if(e.key === 'ArrowDown') moveSelection(r+1,c);
            if(e.key === 'ArrowLeft') moveSelection(r,c-1);
            if(e.key === 'ArrowRight') moveSelection(r,c+1);
          });
        }

        gridElem.appendChild(cell);
      }
    }
    clearSelection();
  }

  // Select cell
  function selectCell(cell, row, col){
    clearSelection();
    selectedCell = {cell, row, col};
    cell.classList.add('highlight');
    cell.focus();
  }

  // Move selection with arrows
  function moveSelection(row, col){
    if(row < 0) row = 8;
    if(row > 8) row = 0;
    if(col < 0) col = 8;
    if(col > 8) col = 0;

    const idx = row * 9 + col;
    const nextCell = gridElem.children[idx];
    if(nextCell && !nextCell.classList.contains('fixed')){
      selectCell(nextCell, row, col);
    }
  }

  // Set cell value and check validity
  function setCellValue(cell, row, col, value){
    if(cell.classList.contains('fixed')) return;

    // Temporarily set value to check validity
    puzzleBoard[row][col] = value;

    // Check if value valid in current puzzle context
    if(value !== 0 && !isValid(puzzleBoard, row, col, value)){
      cell.classList.add('error');
    } else {
      cell.classList.remove('error');
    }

    cell.textContent = value === 0 ? '' : value;

    checkComplete();
  }

  // Clear all selection highlights
  function clearSelection(){
    if(selectedCell){
      selectedCell.cell.classList.remove('highlight');
      selectedCell = null;
    }
  }

  // Check if puzzle is complete and correct
  function checkComplete(){
    for(let r=0; r<9; r++){
      for(let c=0; c<9; c++){
        if(puzzleBoard[r][c] === 0) return false;
        if(!isValid(puzzleBoard, r, c, puzzleBoard[r][c])) return false;
      }
    }
    // Puzzle solved!
    stopTimer();
    calculateScore();
    setTimeout(() => alert(`כל הכבוד! פתרת את הסודוקו!\nנקודות: ${score}`), 100);
    return true;
  }

  // Timer functions
  function startTimer(){
    if(timerRunning)